{"{kadira:flow-router}/client.browserify.js":"0506bd7edeedfb0dda37eaa9d15362c0ca0f904d"}
{"source":"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],2:[function(require,module,exports){\npage = require('page');\nqs   = require('qs');\n\n},{\"page\":3,\"qs\":6}],3:[function(require,module,exports){\n(function (process){\n  /* globals require, module */\n\n  'use strict';\n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = require('path-to-regexp');\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {string|!Function|!Object} path\n   * @param {Function=} fn\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(/** @type {string} */ (path));\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {string}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {string} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) {\n      document.addEventListener(clickEvent, onclick, false);\n    }\n    if (true === options.hashbang) hashbang = true;\n    if (!dispatch) return;\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    document.removeEventListener(clickEvent, onclick, false);\n    window.removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} dispatch\n   * @param {boolean=} push\n   * @return {!Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object=} state\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(base, state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {string} from - if param 'to' is undefined redirects to 'from'\n   * @param {string=} to\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(/** @type {!string} */ (to));\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {string} path\n   * @param {Object=} state\n   * @param {boolean=} init\n   * @param {boolean=} dispatch\n   * @return {!Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  page.dispatch = function(ctx) {\n    var prev = prevContext,\n      i = 0,\n      j = 0;\n\n    prevContext = ctx;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = base + location.hash.replace('#!', '');\n    } else {\n      current = location.pathname + location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    location.href = ctx.canonicalPath;\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {string} val - URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @constructor\n   * @param {string} path\n   * @param {Object=} options\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path,\n      this.keys = [],\n      options);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {string} path\n   * @param {Object} params\n   * @return {boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ('undefined' === typeof window) {\n      return;\n    }\n    if (document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else {\n        page.show(location.pathname + location.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n\n\n    // ensure link\n    var el = e.target;\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName) return;\n\n\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\n\n\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    path = path[0] !== '/' ? '/' + path : path;\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n\n    if (path.indexOf(base) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (base && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null === e.which ? e.button : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return (href && (0 === href.indexOf(origin)));\n  }\n\n  page.sameOrigin = sameOrigin;\n\n}).call(this,require('_process'))\n\n},{\"_process\":1,\"path-to-regexp\":4}],4:[function(require,module,exports){\nvar isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n\n},{\"isarray\":5}],5:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],6:[function(require,module,exports){\n// Load modules\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\n\n// Declare internals\n\nvar internals = {};\n\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n\n},{\"./parse\":7,\"./stringify\":8}],7:[function(require,module,exports){\n// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false\n};\n\n\ninternals.parseValues = function (str, options) {\n\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0, il = parts.length; i < il; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[Utils.decode(part)] = '';\n\n            if (options.strictNullHandling) {\n                obj[Utils.decode(part)] = null;\n            }\n        }\n        else {\n            var key = Utils.decode(part.slice(0, pos));\n            var val = Utils.decode(part.slice(pos + 1));\n\n            if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n                obj[key] = val;\n            }\n            else {\n                obj[key] = [].concat(obj[key]).concat(val);\n            }\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseObject = function (chain, val, options) {\n\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(internals.parseObject(chain, val, options));\n    }\n    else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        var indexString = '' + index;\n        if (!isNaN(index) &&\n            root !== cleanRoot &&\n            indexString === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays &&\n             index <= options.arrayLimit)) {\n\n            obj = [];\n            obj[index] = internals.parseObject(chain, val, options);\n        }\n        else {\n            obj[cleanRoot] = internals.parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseKeys = function (key, val, options) {\n\n    if (!key) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n\n    if (options.allowDots) {\n        key = key.replace(/\\.([^\\.\\[]+)/g, '[$1]');\n    }\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects &&\n            Object.prototype.hasOwnProperty(segment[1])) {\n\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n\n        ++i;\n        if (!options.plainObjects &&\n            Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n\n            if (!options.allowPrototypes) {\n                continue;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return internals.parseObject(keys, val, options);\n};\n\n\nmodule.exports = function (str, options) {\n\n    options = options || {};\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\n\n    if (str === '' ||\n        str === null ||\n        typeof str === 'undefined') {\n\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        var newObj = internals.parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n\n},{\"./utils\":9}],8:[function(require,module,exports){\n// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    arrayPrefixGenerators: {\n        brackets: function (prefix, key) {\n\n            return prefix + '[]';\n        },\n        indices: function (prefix, key) {\n\n            return prefix + '[' + key + ']';\n        },\n        repeat: function (prefix, key) {\n\n            return prefix;\n        }\n    },\n    strictNullHandling: false,\n    skipNulls: false,\n    encode: true\n};\n\n\ninternals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort) {\n\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    }\n    else if (Utils.isBuffer(obj)) {\n        obj = obj.toString();\n    }\n    else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    }\n    else if (obj === null) {\n        if (strictNullHandling) {\n            return encode ? Utils.encode(prefix) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' ||\n        typeof obj === 'number' ||\n        typeof obj === 'boolean') {\n\n        if (encode) {\n            return [Utils.encode(prefix) + '=' + Utils.encode(obj)];\n        }\n        return [prefix + '=' + obj];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls &&\n            obj[key] === null) {\n\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));\n        }\n        else {\n            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));\n        }\n    }\n\n    return values;\n};\n\n\nmodule.exports = function (obj, options) {\n\n    options = options || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : internals.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : internals.encode;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var objKeys;\n    var filter;\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    }\n    else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in internals.arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    }\n    else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    }\n    else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls &&\n            obj[key] === null) {\n\n            continue;\n        }\n\n        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort));\n    }\n\n    return keys.join(delimiter);\n};\n\n},{\"./utils\":9}],9:[function(require,module,exports){\n// Load modules\n\n\n// Declare internals\n\nvar internals = {};\ninternals.hexTable = new Array(256);\nfor (var h = 0; h < 256; ++h) {\n    internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();\n}\n\n\nexports.arrayToObject = function (source, options) {\n\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0, il = source.length; i < il; ++i) {\n        if (typeof source[i] !== 'undefined') {\n\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\n\nexports.merge = function (target, source, options) {\n\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        }\n        else if (typeof target === 'object') {\n            target[source] = true;\n        }\n        else {\n            target = [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        target = [target].concat(source);\n        return target;\n    }\n\n    if (Array.isArray(target) &&\n        !Array.isArray(source)) {\n\n        target = exports.arrayToObject(target, options);\n    }\n\n    var keys = Object.keys(source);\n    for (var k = 0, kl = keys.length; k < kl; ++k) {\n        var key = keys[k];\n        var value = source[key];\n\n        if (!Object.prototype.hasOwnProperty.call(target, key)) {\n            target[key] = value;\n        }\n        else {\n            target[key] = exports.merge(target[key], value, options);\n        }\n    }\n\n    return target;\n};\n\n\nexports.decode = function (str) {\n\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    if (typeof str !== 'string') {\n        str = '' + str;\n    }\n\n    var out = '';\n    for (var i = 0, il = str.length; i < il; ++i) {\n        var c = str.charCodeAt(i);\n\n        if (c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A)) { // A-Z\n\n            out += str[i];\n            continue;\n        }\n\n        if (c < 0x80) {\n            out += internals.hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];\n            continue;\n        }\n\n        ++i;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));\n        out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, refs) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    refs = refs || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0, il = obj.length; i < il; ++i) {\n            if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\n\nexports.isRegExp = function (obj) {\n\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\n\nexports.isBuffer = function (obj) {\n\n    if (obj === null ||\n        typeof obj === 'undefined') {\n\n        return false;\n    }\n\n    return !!(obj.constructor &&\n              obj.constructor.isBuffer &&\n              obj.constructor.isBuffer(obj));\n};\n\n},{}]},{},[2])\n//# sourceMappingURL=/packages/kadira_flow-router/client.browserify.js\n","sourceMap":"{\n  \"version\": 3,\n  \"sources\": [\n    \"../../../cosmos_browserify/.0.9.3.1n7ftzm++os+web.browser+web.cordova/plugin.CosmosBrowserify.os/npm/CosmosBrowserify/node_modules/browserify/node_modules/browser-pack/_prelude.js\",\n    \"../../../cosmos_browserify/.0.9.3.1n7ftzm++os+web.browser+web.cordova/plugin.CosmosBrowserify.os/npm/CosmosBrowserify/node_modules/browserify/node_modules/process/browser.js\",\n    \"_stream_0.js\",\n    \"node_modules/page/index.js\",\n    \"node_modules/page/node_modules/path-to-regexp/index.js\",\n    \"node_modules/page/node_modules/path-to-regexp/node_modules/isarray/index.js\",\n    \"node_modules/qs/lib/index.js\",\n    \"node_modules/qs/lib/parse.js\",\n    \"node_modules/qs/lib/stringify.js\",\n    \"node_modules/qs/lib/utils.js\"\n  ],\n  \"names\": [],\n  \"mappings\": \"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtYA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA\",\n  \"file\": \"generated.js\",\n  \"sourceRoot\": \"\",\n  \"sourcesContent\": [\n    \"(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\"function\\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\\"Cannot find module '\\\"+o+\\\"'\\\");throw f.code=\\\"MODULE_NOT_FOUND\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\"function\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})\",\n    \"// shim for using process in browser\\n\\nvar process = module.exports = {};\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = setTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    clearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        setTimeout(drainQueue, 0);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\",\n    \"page = require('page');\\nqs   = require('qs');\\n\",\n    \"  /* globals require, module */\\n\\n  'use strict';\\n\\n  /**\\n   * Module dependencies.\\n   */\\n\\n  var pathtoRegexp = require('path-to-regexp');\\n\\n  /**\\n   * Module exports.\\n   */\\n\\n  module.exports = page;\\n\\n  /**\\n   * Detect click event\\n   */\\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\\n\\n  /**\\n   * To work properly with the URL\\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\\n   */\\n\\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\\n\\n  /**\\n   * Perform initial dispatch.\\n   */\\n\\n  var dispatch = true;\\n\\n\\n  /**\\n   * Decode URL components (query string, pathname, hash).\\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\\n   */\\n  var decodeURLComponents = true;\\n\\n  /**\\n   * Base path.\\n   */\\n\\n  var base = '';\\n\\n  /**\\n   * Running flag.\\n   */\\n\\n  var running;\\n\\n  /**\\n   * HashBang option\\n   */\\n\\n  var hashbang = false;\\n\\n  /**\\n   * Previous context, for capturing\\n   * page exit events.\\n   */\\n\\n  var prevContext;\\n\\n  /**\\n   * Register `path` with callback `fn()`,\\n   * or route `path`, or redirection,\\n   * or `page.start()`.\\n   *\\n   *   page(fn);\\n   *   page('*', fn);\\n   *   page('/user/:id', load, user);\\n   *   page('/user/' + user.id, { some: 'thing' });\\n   *   page('/user/' + user.id);\\n   *   page('/from', '/to')\\n   *   page();\\n   *\\n   * @param {string|!Function|!Object} path\\n   * @param {Function=} fn\\n   * @api public\\n   */\\n\\n  function page(path, fn) {\\n    // <callback>\\n    if ('function' === typeof path) {\\n      return page('*', path);\\n    }\\n\\n    // route <path> to <callback ...>\\n    if ('function' === typeof fn) {\\n      var route = new Route(/** @type {string} */ (path));\\n      for (var i = 1; i < arguments.length; ++i) {\\n        page.callbacks.push(route.middleware(arguments[i]));\\n      }\\n      // show <path> with [state]\\n    } else if ('string' === typeof path) {\\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\\n      // start [options]\\n    } else {\\n      page.start(path);\\n    }\\n  }\\n\\n  /**\\n   * Callback functions.\\n   */\\n\\n  page.callbacks = [];\\n  page.exits = [];\\n\\n  /**\\n   * Current path being processed\\n   * @type {string}\\n   */\\n  page.current = '';\\n\\n  /**\\n   * Number of pages navigated to.\\n   * @type {number}\\n   *\\n   *     page.len == 0;\\n   *     page('/login');\\n   *     page.len == 1;\\n   */\\n\\n  page.len = 0;\\n\\n  /**\\n   * Get or set basepath to `path`.\\n   *\\n   * @param {string} path\\n   * @api public\\n   */\\n\\n  page.base = function(path) {\\n    if (0 === arguments.length) return base;\\n    base = path;\\n  };\\n\\n  /**\\n   * Bind with the given `options`.\\n   *\\n   * Options:\\n   *\\n   *    - `click` bind to click events [true]\\n   *    - `popstate` bind to popstate [true]\\n   *    - `dispatch` perform initial dispatch [true]\\n   *\\n   * @param {Object} options\\n   * @api public\\n   */\\n\\n  page.start = function(options) {\\n    options = options || {};\\n    if (running) return;\\n    running = true;\\n    if (false === options.dispatch) dispatch = false;\\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\\n    if (false !== options.click) {\\n      document.addEventListener(clickEvent, onclick, false);\\n    }\\n    if (true === options.hashbang) hashbang = true;\\n    if (!dispatch) return;\\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\\n    page.replace(url, null, true, dispatch);\\n  };\\n\\n  /**\\n   * Unbind click and popstate event handlers.\\n   *\\n   * @api public\\n   */\\n\\n  page.stop = function() {\\n    if (!running) return;\\n    page.current = '';\\n    page.len = 0;\\n    running = false;\\n    document.removeEventListener(clickEvent, onclick, false);\\n    window.removeEventListener('popstate', onpopstate, false);\\n  };\\n\\n  /**\\n   * Show `path` with optional `state` object.\\n   *\\n   * @param {string} path\\n   * @param {Object=} state\\n   * @param {boolean=} dispatch\\n   * @param {boolean=} push\\n   * @return {!Context}\\n   * @api public\\n   */\\n\\n  page.show = function(path, state, dispatch, push) {\\n    var ctx = new Context(path, state);\\n    page.current = ctx.path;\\n    if (false !== dispatch) page.dispatch(ctx);\\n    if (false !== ctx.handled && false !== push) ctx.pushState();\\n    return ctx;\\n  };\\n\\n  /**\\n   * Goes back in the history\\n   * Back should always let the current route push state and then go back.\\n   *\\n   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base\\n   * @param {Object=} state\\n   * @api public\\n   */\\n\\n  page.back = function(path, state) {\\n    if (page.len > 0) {\\n      // this may need more testing to see if all browsers\\n      // wait for the next tick to go back in history\\n      history.back();\\n      page.len--;\\n    } else if (path) {\\n      setTimeout(function() {\\n        page.show(path, state);\\n      });\\n    }else{\\n      setTimeout(function() {\\n        page.show(base, state);\\n      });\\n    }\\n  };\\n\\n\\n  /**\\n   * Register route to redirect from one path to other\\n   * or just redirect to another route\\n   *\\n   * @param {string} from - if param 'to' is undefined redirects to 'from'\\n   * @param {string=} to\\n   * @api public\\n   */\\n  page.redirect = function(from, to) {\\n    // Define route from a path to another\\n    if ('string' === typeof from && 'string' === typeof to) {\\n      page(from, function(e) {\\n        setTimeout(function() {\\n          page.replace(/** @type {!string} */ (to));\\n        }, 0);\\n      });\\n    }\\n\\n    // Wait for the push state and replace it with another\\n    if ('string' === typeof from && 'undefined' === typeof to) {\\n      setTimeout(function() {\\n        page.replace(from);\\n      }, 0);\\n    }\\n  };\\n\\n  /**\\n   * Replace `path` with optional `state` object.\\n   *\\n   * @param {string} path\\n   * @param {Object=} state\\n   * @param {boolean=} init\\n   * @param {boolean=} dispatch\\n   * @return {!Context}\\n   * @api public\\n   */\\n\\n\\n  page.replace = function(path, state, init, dispatch) {\\n    var ctx = new Context(path, state);\\n    page.current = ctx.path;\\n    ctx.init = init;\\n    ctx.save(); // save before dispatching, which may redirect\\n    if (false !== dispatch) page.dispatch(ctx);\\n    return ctx;\\n  };\\n\\n  /**\\n   * Dispatch the given `ctx`.\\n   *\\n   * @param {Context} ctx\\n   * @api private\\n   */\\n  page.dispatch = function(ctx) {\\n    var prev = prevContext,\\n      i = 0,\\n      j = 0;\\n\\n    prevContext = ctx;\\n\\n    function nextExit() {\\n      var fn = page.exits[j++];\\n      if (!fn) return nextEnter();\\n      fn(prev, nextExit);\\n    }\\n\\n    function nextEnter() {\\n      var fn = page.callbacks[i++];\\n\\n      if (ctx.path !== page.current) {\\n        ctx.handled = false;\\n        return;\\n      }\\n      if (!fn) return unhandled(ctx);\\n      fn(ctx, nextEnter);\\n    }\\n\\n    if (prev) {\\n      nextExit();\\n    } else {\\n      nextEnter();\\n    }\\n  };\\n\\n  /**\\n   * Unhandled `ctx`. When it's not the initial\\n   * popstate then redirect. If you wish to handle\\n   * 404s on your own use `page('*', callback)`.\\n   *\\n   * @param {Context} ctx\\n   * @api private\\n   */\\n  function unhandled(ctx) {\\n    if (ctx.handled) return;\\n    var current;\\n\\n    if (hashbang) {\\n      current = base + location.hash.replace('#!', '');\\n    } else {\\n      current = location.pathname + location.search;\\n    }\\n\\n    if (current === ctx.canonicalPath) return;\\n    page.stop();\\n    ctx.handled = false;\\n    location.href = ctx.canonicalPath;\\n  }\\n\\n  /**\\n   * Register an exit route on `path` with\\n   * callback `fn()`, which will be called\\n   * on the previous context when a new\\n   * page is visited.\\n   */\\n  page.exit = function(path, fn) {\\n    if (typeof path === 'function') {\\n      return page.exit('*', path);\\n    }\\n\\n    var route = new Route(path);\\n    for (var i = 1; i < arguments.length; ++i) {\\n      page.exits.push(route.middleware(arguments[i]));\\n    }\\n  };\\n\\n  /**\\n   * Remove URL encoding from the given `str`.\\n   * Accommodates whitespace in both x-www-form-urlencoded\\n   * and regular percent-encoded form.\\n   *\\n   * @param {string} val - URL component to decode\\n   */\\n  function decodeURLEncodedURIComponent(val) {\\n    if (typeof val !== 'string') { return val; }\\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\\\+/g, ' ')) : val;\\n  }\\n\\n  /**\\n   * Initialize a new \\\"request\\\" `Context`\\n   * with the given `path` and optional initial `state`.\\n   *\\n   * @constructor\\n   * @param {string} path\\n   * @param {Object=} state\\n   * @api public\\n   */\\n\\n  function Context(path, state) {\\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\\n    var i = path.indexOf('?');\\n\\n    this.canonicalPath = path;\\n    this.path = path.replace(base, '') || '/';\\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\\n\\n    this.title = document.title;\\n    this.state = state || {};\\n    this.state.path = path;\\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\\n    this.params = {};\\n\\n    // fragment\\n    this.hash = '';\\n    if (!hashbang) {\\n      if (!~this.path.indexOf('#')) return;\\n      var parts = this.path.split('#');\\n      this.path = parts[0];\\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\\n      this.querystring = this.querystring.split('#')[0];\\n    }\\n  }\\n\\n  /**\\n   * Expose `Context`.\\n   */\\n\\n  page.Context = Context;\\n\\n  /**\\n   * Push state.\\n   *\\n   * @api private\\n   */\\n\\n  Context.prototype.pushState = function() {\\n    page.len++;\\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\\n  };\\n\\n  /**\\n   * Save the context state.\\n   *\\n   * @api public\\n   */\\n\\n  Context.prototype.save = function() {\\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\\n  };\\n\\n  /**\\n   * Initialize `Route` with the given HTTP `path`,\\n   * and an array of `callbacks` and `options`.\\n   *\\n   * Options:\\n   *\\n   *   - `sensitive`    enable case-sensitive routes\\n   *   - `strict`       enable strict matching for trailing slashes\\n   *\\n   * @constructor\\n   * @param {string} path\\n   * @param {Object=} options\\n   * @api private\\n   */\\n\\n  function Route(path, options) {\\n    options = options || {};\\n    this.path = (path === '*') ? '(.*)' : path;\\n    this.method = 'GET';\\n    this.regexp = pathtoRegexp(this.path,\\n      this.keys = [],\\n      options);\\n  }\\n\\n  /**\\n   * Expose `Route`.\\n   */\\n\\n  page.Route = Route;\\n\\n  /**\\n   * Return route middleware with\\n   * the given callback `fn()`.\\n   *\\n   * @param {Function} fn\\n   * @return {Function}\\n   * @api public\\n   */\\n\\n  Route.prototype.middleware = function(fn) {\\n    var self = this;\\n    return function(ctx, next) {\\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\\n      next();\\n    };\\n  };\\n\\n  /**\\n   * Check if this route matches `path`, if so\\n   * populate `params`.\\n   *\\n   * @param {string} path\\n   * @param {Object} params\\n   * @return {boolean}\\n   * @api private\\n   */\\n\\n  Route.prototype.match = function(path, params) {\\n    var keys = this.keys,\\n      qsIndex = path.indexOf('?'),\\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\\n      m = this.regexp.exec(decodeURIComponent(pathname));\\n\\n    if (!m) return false;\\n\\n    for (var i = 1, len = m.length; i < len; ++i) {\\n      var key = keys[i - 1];\\n      var val = decodeURLEncodedURIComponent(m[i]);\\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\\n        params[key.name] = val;\\n      }\\n    }\\n\\n    return true;\\n  };\\n\\n\\n  /**\\n   * Handle \\\"populate\\\" events.\\n   */\\n\\n  var onpopstate = (function () {\\n    var loaded = false;\\n    if ('undefined' === typeof window) {\\n      return;\\n    }\\n    if (document.readyState === 'complete') {\\n      loaded = true;\\n    } else {\\n      window.addEventListener('load', function() {\\n        setTimeout(function() {\\n          loaded = true;\\n        }, 0);\\n      });\\n    }\\n    return function onpopstate(e) {\\n      if (!loaded) return;\\n      if (e.state) {\\n        var path = e.state.path;\\n        page.replace(path, e.state);\\n      } else {\\n        page.show(location.pathname + location.hash, undefined, undefined, false);\\n      }\\n    };\\n  })();\\n  /**\\n   * Handle \\\"click\\\" events.\\n   */\\n\\n  function onclick(e) {\\n\\n    if (1 !== which(e)) return;\\n\\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\\n    if (e.defaultPrevented) return;\\n\\n\\n\\n    // ensure link\\n    var el = e.target;\\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\\n    if (!el || 'A' !== el.nodeName) return;\\n\\n\\n\\n    // Ignore if tag has\\n    // 1. \\\"download\\\" attribute\\n    // 2. rel=\\\"external\\\" attribute\\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\\n\\n    // ensure non-hash for the same path\\n    var link = el.getAttribute('href');\\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\\n\\n\\n\\n    // Check for mailto: in the href\\n    if (link && link.indexOf('mailto:') > -1) return;\\n\\n    // check target\\n    if (el.target) return;\\n\\n    // x-origin\\n    if (!sameOrigin(el.href)) return;\\n\\n\\n\\n    // rebuild path\\n    var path = el.pathname + el.search + (el.hash || '');\\n\\n    path = path[0] !== '/' ? '/' + path : path;\\n\\n    // strip leading \\\"/[drive letter]:\\\" on NW.js on Windows\\n    if (typeof process !== 'undefined' && path.match(/^\\\\/[a-zA-Z]:\\\\//)) {\\n      path = path.replace(/^\\\\/[a-zA-Z]:\\\\//, '/');\\n    }\\n\\n    // same page\\n    var orig = path;\\n\\n    if (path.indexOf(base) === 0) {\\n      path = path.substr(base.length);\\n    }\\n\\n    if (hashbang) path = path.replace('#!', '');\\n\\n    if (base && orig === path) return;\\n\\n    e.preventDefault();\\n    page.show(orig);\\n  }\\n\\n  /**\\n   * Event button.\\n   */\\n\\n  function which(e) {\\n    e = e || window.event;\\n    return null === e.which ? e.button : e.which;\\n  }\\n\\n  /**\\n   * Check if `href` is the same origin.\\n   */\\n\\n  function sameOrigin(href) {\\n    var origin = location.protocol + '//' + location.hostname;\\n    if (location.port) origin += ':' + location.port;\\n    return (href && (0 === href.indexOf(origin)));\\n  }\\n\\n  page.sameOrigin = sameOrigin;\\n\",\n    \"var isarray = require('isarray')\\n\\n/**\\n * Expose `pathToRegexp`.\\n */\\nmodule.exports = pathToRegexp\\nmodule.exports.parse = parse\\nmodule.exports.compile = compile\\nmodule.exports.tokensToFunction = tokensToFunction\\nmodule.exports.tokensToRegExp = tokensToRegExp\\n\\n/**\\n * The main path matching regexp utility.\\n *\\n * @type {RegExp}\\n */\\nvar PATH_REGEXP = new RegExp([\\n  // Match escaped characters that would otherwise appear in future matches.\\n  // This allows the user to escape special characters that won't transform.\\n  '(\\\\\\\\\\\\\\\\.)',\\n  // Match Express-style parameters and un-named parameters with a prefix\\n  // and optional suffixes. Matches appear as:\\n  //\\n  // \\\"/:test(\\\\\\\\d+)?\\\" => [\\\"/\\\", \\\"test\\\", \\\"\\\\d+\\\", undefined, \\\"?\\\", undefined]\\n  // \\\"/route(\\\\\\\\d+)\\\"  => [undefined, undefined, undefined, \\\"\\\\d+\\\", undefined, undefined]\\n  // \\\"/*\\\"            => [\\\"/\\\", undefined, undefined, undefined, undefined, \\\"*\\\"]\\n  '([\\\\\\\\/.])?(?:(?:\\\\\\\\:(\\\\\\\\w+)(?:\\\\\\\\(((?:\\\\\\\\\\\\\\\\.|[^()])+)\\\\\\\\))?|\\\\\\\\(((?:\\\\\\\\\\\\\\\\.|[^()])+)\\\\\\\\))([+*?])?|(\\\\\\\\*))'\\n].join('|'), 'g')\\n\\n/**\\n * Parse a string for the raw tokens.\\n *\\n * @param  {String} str\\n * @return {Array}\\n */\\nfunction parse (str) {\\n  var tokens = []\\n  var key = 0\\n  var index = 0\\n  var path = ''\\n  var res\\n\\n  while ((res = PATH_REGEXP.exec(str)) != null) {\\n    var m = res[0]\\n    var escaped = res[1]\\n    var offset = res.index\\n    path += str.slice(index, offset)\\n    index = offset + m.length\\n\\n    // Ignore already escaped sequences.\\n    if (escaped) {\\n      path += escaped[1]\\n      continue\\n    }\\n\\n    // Push the current path onto the tokens.\\n    if (path) {\\n      tokens.push(path)\\n      path = ''\\n    }\\n\\n    var prefix = res[2]\\n    var name = res[3]\\n    var capture = res[4]\\n    var group = res[5]\\n    var suffix = res[6]\\n    var asterisk = res[7]\\n\\n    var repeat = suffix === '+' || suffix === '*'\\n    var optional = suffix === '?' || suffix === '*'\\n    var delimiter = prefix || '/'\\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\\n\\n    tokens.push({\\n      name: name || key++,\\n      prefix: prefix || '',\\n      delimiter: delimiter,\\n      optional: optional,\\n      repeat: repeat,\\n      pattern: escapeGroup(pattern)\\n    })\\n  }\\n\\n  // Match any characters still remaining.\\n  if (index < str.length) {\\n    path += str.substr(index)\\n  }\\n\\n  // If the path exists, push it onto the end.\\n  if (path) {\\n    tokens.push(path)\\n  }\\n\\n  return tokens\\n}\\n\\n/**\\n * Compile a string to a template function for the path.\\n *\\n * @param  {String}   str\\n * @return {Function}\\n */\\nfunction compile (str) {\\n  return tokensToFunction(parse(str))\\n}\\n\\n/**\\n * Expose a method for transforming tokens into the path function.\\n */\\nfunction tokensToFunction (tokens) {\\n  // Compile all the tokens into regexps.\\n  var matches = new Array(tokens.length)\\n\\n  // Compile all the patterns before compilation.\\n  for (var i = 0; i < tokens.length; i++) {\\n    if (typeof tokens[i] === 'object') {\\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\\n    }\\n  }\\n\\n  return function (obj) {\\n    var path = ''\\n    var data = obj || {}\\n\\n    for (var i = 0; i < tokens.length; i++) {\\n      var token = tokens[i]\\n\\n      if (typeof token === 'string') {\\n        path += token\\n\\n        continue\\n      }\\n\\n      var value = data[token.name]\\n      var segment\\n\\n      if (value == null) {\\n        if (token.optional) {\\n          continue\\n        } else {\\n          throw new TypeError('Expected \\\"' + token.name + '\\\" to be defined')\\n        }\\n      }\\n\\n      if (isarray(value)) {\\n        if (!token.repeat) {\\n          throw new TypeError('Expected \\\"' + token.name + '\\\" to not repeat, but received \\\"' + value + '\\\"')\\n        }\\n\\n        if (value.length === 0) {\\n          if (token.optional) {\\n            continue\\n          } else {\\n            throw new TypeError('Expected \\\"' + token.name + '\\\" to not be empty')\\n          }\\n        }\\n\\n        for (var j = 0; j < value.length; j++) {\\n          segment = encodeURIComponent(value[j])\\n\\n          if (!matches[i].test(segment)) {\\n            throw new TypeError('Expected all \\\"' + token.name + '\\\" to match \\\"' + token.pattern + '\\\", but received \\\"' + segment + '\\\"')\\n          }\\n\\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\\n        }\\n\\n        continue\\n      }\\n\\n      segment = encodeURIComponent(value)\\n\\n      if (!matches[i].test(segment)) {\\n        throw new TypeError('Expected \\\"' + token.name + '\\\" to match \\\"' + token.pattern + '\\\", but received \\\"' + segment + '\\\"')\\n      }\\n\\n      path += token.prefix + segment\\n    }\\n\\n    return path\\n  }\\n}\\n\\n/**\\n * Escape a regular expression string.\\n *\\n * @param  {String} str\\n * @return {String}\\n */\\nfunction escapeString (str) {\\n  return str.replace(/([.+*?=^!:${}()[\\\\]|\\\\/])/g, '\\\\\\\\$1')\\n}\\n\\n/**\\n * Escape the capturing group by escaping special characters and meaning.\\n *\\n * @param  {String} group\\n * @return {String}\\n */\\nfunction escapeGroup (group) {\\n  return group.replace(/([=!:$\\\\/()])/g, '\\\\\\\\$1')\\n}\\n\\n/**\\n * Attach the keys as a property of the regexp.\\n *\\n * @param  {RegExp} re\\n * @param  {Array}  keys\\n * @return {RegExp}\\n */\\nfunction attachKeys (re, keys) {\\n  re.keys = keys\\n  return re\\n}\\n\\n/**\\n * Get the flags for a regexp from the options.\\n *\\n * @param  {Object} options\\n * @return {String}\\n */\\nfunction flags (options) {\\n  return options.sensitive ? '' : 'i'\\n}\\n\\n/**\\n * Pull out keys from a regexp.\\n *\\n * @param  {RegExp} path\\n * @param  {Array}  keys\\n * @return {RegExp}\\n */\\nfunction regexpToRegexp (path, keys) {\\n  // Use a negative lookahead to match only capturing groups.\\n  var groups = path.source.match(/\\\\((?!\\\\?)/g)\\n\\n  if (groups) {\\n    for (var i = 0; i < groups.length; i++) {\\n      keys.push({\\n        name: i,\\n        prefix: null,\\n        delimiter: null,\\n        optional: false,\\n        repeat: false,\\n        pattern: null\\n      })\\n    }\\n  }\\n\\n  return attachKeys(path, keys)\\n}\\n\\n/**\\n * Transform an array into a regexp.\\n *\\n * @param  {Array}  path\\n * @param  {Array}  keys\\n * @param  {Object} options\\n * @return {RegExp}\\n */\\nfunction arrayToRegexp (path, keys, options) {\\n  var parts = []\\n\\n  for (var i = 0; i < path.length; i++) {\\n    parts.push(pathToRegexp(path[i], keys, options).source)\\n  }\\n\\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\\n\\n  return attachKeys(regexp, keys)\\n}\\n\\n/**\\n * Create a path regexp from string input.\\n *\\n * @param  {String} path\\n * @param  {Array}  keys\\n * @param  {Object} options\\n * @return {RegExp}\\n */\\nfunction stringToRegexp (path, keys, options) {\\n  var tokens = parse(path)\\n  var re = tokensToRegExp(tokens, options)\\n\\n  // Attach keys back to the regexp.\\n  for (var i = 0; i < tokens.length; i++) {\\n    if (typeof tokens[i] !== 'string') {\\n      keys.push(tokens[i])\\n    }\\n  }\\n\\n  return attachKeys(re, keys)\\n}\\n\\n/**\\n * Expose a function for taking tokens and returning a RegExp.\\n *\\n * @param  {Array}  tokens\\n * @param  {Array}  keys\\n * @param  {Object} options\\n * @return {RegExp}\\n */\\nfunction tokensToRegExp (tokens, options) {\\n  options = options || {}\\n\\n  var strict = options.strict\\n  var end = options.end !== false\\n  var route = ''\\n  var lastToken = tokens[tokens.length - 1]\\n  var endsWithSlash = typeof lastToken === 'string' && /\\\\/$/.test(lastToken)\\n\\n  // Iterate over the tokens and create our regexp string.\\n  for (var i = 0; i < tokens.length; i++) {\\n    var token = tokens[i]\\n\\n    if (typeof token === 'string') {\\n      route += escapeString(token)\\n    } else {\\n      var prefix = escapeString(token.prefix)\\n      var capture = token.pattern\\n\\n      if (token.repeat) {\\n        capture += '(?:' + prefix + capture + ')*'\\n      }\\n\\n      if (token.optional) {\\n        if (prefix) {\\n          capture = '(?:' + prefix + '(' + capture + '))?'\\n        } else {\\n          capture = '(' + capture + ')?'\\n        }\\n      } else {\\n        capture = prefix + '(' + capture + ')'\\n      }\\n\\n      route += capture\\n    }\\n  }\\n\\n  // In non-strict mode we allow a slash at the end of match. If the path to\\n  // match already ends with a slash, we remove it for consistency. The slash\\n  // is valid at the end of a path match, not in the middle. This is important\\n  // in non-ending mode, where \\\"/test/\\\" shouldn't match \\\"/test//route\\\".\\n  if (!strict) {\\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\\\\\/(?=$))?'\\n  }\\n\\n  if (end) {\\n    route += '$'\\n  } else {\\n    // In non-ending mode, we need the capturing groups to match as much as\\n    // possible by using a positive lookahead to the end or next path segment.\\n    route += strict && endsWithSlash ? '' : '(?=\\\\\\\\/|$)'\\n  }\\n\\n  return new RegExp('^' + route, flags(options))\\n}\\n\\n/**\\n * Normalize the given path string, returning a regular expression.\\n *\\n * An empty array can be passed in for the keys, which will hold the\\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\\n *\\n * @param  {(String|RegExp|Array)} path\\n * @param  {Array}                 [keys]\\n * @param  {Object}                [options]\\n * @return {RegExp}\\n */\\nfunction pathToRegexp (path, keys, options) {\\n  keys = keys || []\\n\\n  if (!isarray(keys)) {\\n    options = keys\\n    keys = []\\n  } else if (!options) {\\n    options = {}\\n  }\\n\\n  if (path instanceof RegExp) {\\n    return regexpToRegexp(path, keys, options)\\n  }\\n\\n  if (isarray(path)) {\\n    return arrayToRegexp(path, keys, options)\\n  }\\n\\n  return stringToRegexp(path, keys, options)\\n}\\n\",\n    \"module.exports = Array.isArray || function (arr) {\\n  return Object.prototype.toString.call(arr) == '[object Array]';\\n};\\n\",\n    \"// Load modules\\n\\nvar Stringify = require('./stringify');\\nvar Parse = require('./parse');\\n\\n\\n// Declare internals\\n\\nvar internals = {};\\n\\n\\nmodule.exports = {\\n    stringify: Stringify,\\n    parse: Parse\\n};\\n\",\n    \"// Load modules\\n\\nvar Utils = require('./utils');\\n\\n\\n// Declare internals\\n\\nvar internals = {\\n    delimiter: '&',\\n    depth: 5,\\n    arrayLimit: 20,\\n    parameterLimit: 1000,\\n    strictNullHandling: false,\\n    plainObjects: false,\\n    allowPrototypes: false,\\n    allowDots: false\\n};\\n\\n\\ninternals.parseValues = function (str, options) {\\n\\n    var obj = {};\\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\\n\\n    for (var i = 0, il = parts.length; i < il; ++i) {\\n        var part = parts[i];\\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\\n\\n        if (pos === -1) {\\n            obj[Utils.decode(part)] = '';\\n\\n            if (options.strictNullHandling) {\\n                obj[Utils.decode(part)] = null;\\n            }\\n        }\\n        else {\\n            var key = Utils.decode(part.slice(0, pos));\\n            var val = Utils.decode(part.slice(pos + 1));\\n\\n            if (!Object.prototype.hasOwnProperty.call(obj, key)) {\\n                obj[key] = val;\\n            }\\n            else {\\n                obj[key] = [].concat(obj[key]).concat(val);\\n            }\\n        }\\n    }\\n\\n    return obj;\\n};\\n\\n\\ninternals.parseObject = function (chain, val, options) {\\n\\n    if (!chain.length) {\\n        return val;\\n    }\\n\\n    var root = chain.shift();\\n\\n    var obj;\\n    if (root === '[]') {\\n        obj = [];\\n        obj = obj.concat(internals.parseObject(chain, val, options));\\n    }\\n    else {\\n        obj = options.plainObjects ? Object.create(null) : {};\\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\\n        var index = parseInt(cleanRoot, 10);\\n        var indexString = '' + index;\\n        if (!isNaN(index) &&\\n            root !== cleanRoot &&\\n            indexString === cleanRoot &&\\n            index >= 0 &&\\n            (options.parseArrays &&\\n             index <= options.arrayLimit)) {\\n\\n            obj = [];\\n            obj[index] = internals.parseObject(chain, val, options);\\n        }\\n        else {\\n            obj[cleanRoot] = internals.parseObject(chain, val, options);\\n        }\\n    }\\n\\n    return obj;\\n};\\n\\n\\ninternals.parseKeys = function (key, val, options) {\\n\\n    if (!key) {\\n        return;\\n    }\\n\\n    // Transform dot notation to bracket notation\\n\\n    if (options.allowDots) {\\n        key = key.replace(/\\\\.([^\\\\.\\\\[]+)/g, '[$1]');\\n    }\\n\\n    // The regex chunks\\n\\n    var parent = /^([^\\\\[\\\\]]*)/;\\n    var child = /(\\\\[[^\\\\[\\\\]]*\\\\])/g;\\n\\n    // Get the parent\\n\\n    var segment = parent.exec(key);\\n\\n    // Stash the parent if it exists\\n\\n    var keys = [];\\n    if (segment[1]) {\\n        // If we aren't using plain objects, optionally prefix keys\\n        // that would overwrite object prototype properties\\n        if (!options.plainObjects &&\\n            Object.prototype.hasOwnProperty(segment[1])) {\\n\\n            if (!options.allowPrototypes) {\\n                return;\\n            }\\n        }\\n\\n        keys.push(segment[1]);\\n    }\\n\\n    // Loop through children appending to the array until we hit depth\\n\\n    var i = 0;\\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\\n\\n        ++i;\\n        if (!options.plainObjects &&\\n            Object.prototype.hasOwnProperty(segment[1].replace(/\\\\[|\\\\]/g, ''))) {\\n\\n            if (!options.allowPrototypes) {\\n                continue;\\n            }\\n        }\\n        keys.push(segment[1]);\\n    }\\n\\n    // If there's a remainder, just add whatever is left\\n\\n    if (segment) {\\n        keys.push('[' + key.slice(segment.index) + ']');\\n    }\\n\\n    return internals.parseObject(keys, val, options);\\n};\\n\\n\\nmodule.exports = function (str, options) {\\n\\n    options = options || {};\\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\\n    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\\n    options.parseArrays = options.parseArrays !== false;\\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;\\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;\\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;\\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\\n\\n    if (str === '' ||\\n        str === null ||\\n        typeof str === 'undefined') {\\n\\n        return options.plainObjects ? Object.create(null) : {};\\n    }\\n\\n    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\\n    var obj = options.plainObjects ? Object.create(null) : {};\\n\\n    // Iterate over the keys and setup the new object\\n\\n    var keys = Object.keys(tempObj);\\n    for (var i = 0, il = keys.length; i < il; ++i) {\\n        var key = keys[i];\\n        var newObj = internals.parseKeys(key, tempObj[key], options);\\n        obj = Utils.merge(obj, newObj, options);\\n    }\\n\\n    return Utils.compact(obj);\\n};\\n\",\n    \"// Load modules\\n\\nvar Utils = require('./utils');\\n\\n\\n// Declare internals\\n\\nvar internals = {\\n    delimiter: '&',\\n    arrayPrefixGenerators: {\\n        brackets: function (prefix, key) {\\n\\n            return prefix + '[]';\\n        },\\n        indices: function (prefix, key) {\\n\\n            return prefix + '[' + key + ']';\\n        },\\n        repeat: function (prefix, key) {\\n\\n            return prefix;\\n        }\\n    },\\n    strictNullHandling: false,\\n    skipNulls: false,\\n    encode: true\\n};\\n\\n\\ninternals.stringify = function (obj, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort) {\\n\\n    if (typeof filter === 'function') {\\n        obj = filter(prefix, obj);\\n    }\\n    else if (Utils.isBuffer(obj)) {\\n        obj = obj.toString();\\n    }\\n    else if (obj instanceof Date) {\\n        obj = obj.toISOString();\\n    }\\n    else if (obj === null) {\\n        if (strictNullHandling) {\\n            return encode ? Utils.encode(prefix) : prefix;\\n        }\\n\\n        obj = '';\\n    }\\n\\n    if (typeof obj === 'string' ||\\n        typeof obj === 'number' ||\\n        typeof obj === 'boolean') {\\n\\n        if (encode) {\\n            return [Utils.encode(prefix) + '=' + Utils.encode(obj)];\\n        }\\n        return [prefix + '=' + obj];\\n    }\\n\\n    var values = [];\\n\\n    if (typeof obj === 'undefined') {\\n        return values;\\n    }\\n\\n    var objKeys;\\n    if (Array.isArray(filter)) {\\n        objKeys = filter;\\n    } else {\\n        var keys = Object.keys(obj);\\n        objKeys = sort ? keys.sort(sort) : keys;\\n    }\\n\\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\\n        var key = objKeys[i];\\n\\n        if (skipNulls &&\\n            obj[key] === null) {\\n\\n            continue;\\n        }\\n\\n        if (Array.isArray(obj)) {\\n            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));\\n        }\\n        else {\\n            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix, strictNullHandling, skipNulls, encode, filter));\\n        }\\n    }\\n\\n    return values;\\n};\\n\\n\\nmodule.exports = function (obj, options) {\\n\\n    options = options || {};\\n    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;\\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : internals.skipNulls;\\n    var encode = typeof options.encode === 'boolean' ? options.encode : internals.encode;\\n    var sort = typeof options.sort === 'function' ? options.sort : null;\\n    var objKeys;\\n    var filter;\\n    if (typeof options.filter === 'function') {\\n        filter = options.filter;\\n        obj = filter('', obj);\\n    }\\n    else if (Array.isArray(options.filter)) {\\n        objKeys = filter = options.filter;\\n    }\\n\\n    var keys = [];\\n\\n    if (typeof obj !== 'object' ||\\n        obj === null) {\\n\\n        return '';\\n    }\\n\\n    var arrayFormat;\\n    if (options.arrayFormat in internals.arrayPrefixGenerators) {\\n        arrayFormat = options.arrayFormat;\\n    }\\n    else if ('indices' in options) {\\n        arrayFormat = options.indices ? 'indices' : 'repeat';\\n    }\\n    else {\\n        arrayFormat = 'indices';\\n    }\\n\\n    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];\\n\\n    if (!objKeys) {\\n        objKeys = Object.keys(obj);\\n    }\\n\\n    if (sort) {\\n        objKeys.sort(sort);\\n    }\\n\\n    for (var i = 0, il = objKeys.length; i < il; ++i) {\\n        var key = objKeys[i];\\n\\n        if (skipNulls &&\\n            obj[key] === null) {\\n\\n            continue;\\n        }\\n\\n        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort));\\n    }\\n\\n    return keys.join(delimiter);\\n};\\n\",\n    \"// Load modules\\n\\n\\n// Declare internals\\n\\nvar internals = {};\\ninternals.hexTable = new Array(256);\\nfor (var h = 0; h < 256; ++h) {\\n    internals.hexTable[h] = '%' + ((h < 16 ? '0' : '') + h.toString(16)).toUpperCase();\\n}\\n\\n\\nexports.arrayToObject = function (source, options) {\\n\\n    var obj = options.plainObjects ? Object.create(null) : {};\\n    for (var i = 0, il = source.length; i < il; ++i) {\\n        if (typeof source[i] !== 'undefined') {\\n\\n            obj[i] = source[i];\\n        }\\n    }\\n\\n    return obj;\\n};\\n\\n\\nexports.merge = function (target, source, options) {\\n\\n    if (!source) {\\n        return target;\\n    }\\n\\n    if (typeof source !== 'object') {\\n        if (Array.isArray(target)) {\\n            target.push(source);\\n        }\\n        else if (typeof target === 'object') {\\n            target[source] = true;\\n        }\\n        else {\\n            target = [target, source];\\n        }\\n\\n        return target;\\n    }\\n\\n    if (typeof target !== 'object') {\\n        target = [target].concat(source);\\n        return target;\\n    }\\n\\n    if (Array.isArray(target) &&\\n        !Array.isArray(source)) {\\n\\n        target = exports.arrayToObject(target, options);\\n    }\\n\\n    var keys = Object.keys(source);\\n    for (var k = 0, kl = keys.length; k < kl; ++k) {\\n        var key = keys[k];\\n        var value = source[key];\\n\\n        if (!Object.prototype.hasOwnProperty.call(target, key)) {\\n            target[key] = value;\\n        }\\n        else {\\n            target[key] = exports.merge(target[key], value, options);\\n        }\\n    }\\n\\n    return target;\\n};\\n\\n\\nexports.decode = function (str) {\\n\\n    try {\\n        return decodeURIComponent(str.replace(/\\\\+/g, ' '));\\n    } catch (e) {\\n        return str;\\n    }\\n};\\n\\nexports.encode = function (str) {\\n\\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\\n    // It has been adapted here for stricter adherence to RFC 3986\\n    if (str.length === 0) {\\n        return str;\\n    }\\n\\n    if (typeof str !== 'string') {\\n        str = '' + str;\\n    }\\n\\n    var out = '';\\n    for (var i = 0, il = str.length; i < il; ++i) {\\n        var c = str.charCodeAt(i);\\n\\n        if (c === 0x2D || // -\\n            c === 0x2E || // .\\n            c === 0x5F || // _\\n            c === 0x7E || // ~\\n            (c >= 0x30 && c <= 0x39) || // 0-9\\n            (c >= 0x41 && c <= 0x5A) || // a-z\\n            (c >= 0x61 && c <= 0x7A)) { // A-Z\\n\\n            out += str[i];\\n            continue;\\n        }\\n\\n        if (c < 0x80) {\\n            out += internals.hexTable[c];\\n            continue;\\n        }\\n\\n        if (c < 0x800) {\\n            out += internals.hexTable[0xC0 | (c >> 6)] + internals.hexTable[0x80 | (c & 0x3F)];\\n            continue;\\n        }\\n\\n        if (c < 0xD800 || c >= 0xE000) {\\n            out += internals.hexTable[0xE0 | (c >> 12)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];\\n            continue;\\n        }\\n\\n        ++i;\\n        c = 0x10000 + (((c & 0x3FF) << 10) | (str.charCodeAt(i) & 0x3FF));\\n        out += internals.hexTable[0xF0 | (c >> 18)] + internals.hexTable[0x80 | ((c >> 12) & 0x3F)] + internals.hexTable[0x80 | ((c >> 6) & 0x3F)] + internals.hexTable[0x80 | (c & 0x3F)];\\n    }\\n\\n    return out;\\n};\\n\\nexports.compact = function (obj, refs) {\\n\\n    if (typeof obj !== 'object' ||\\n        obj === null) {\\n\\n        return obj;\\n    }\\n\\n    refs = refs || [];\\n    var lookup = refs.indexOf(obj);\\n    if (lookup !== -1) {\\n        return refs[lookup];\\n    }\\n\\n    refs.push(obj);\\n\\n    if (Array.isArray(obj)) {\\n        var compacted = [];\\n\\n        for (var i = 0, il = obj.length; i < il; ++i) {\\n            if (typeof obj[i] !== 'undefined') {\\n                compacted.push(obj[i]);\\n            }\\n        }\\n\\n        return compacted;\\n    }\\n\\n    var keys = Object.keys(obj);\\n    for (i = 0, il = keys.length; i < il; ++i) {\\n        var key = keys[i];\\n        obj[key] = exports.compact(obj[key], refs);\\n    }\\n\\n    return obj;\\n};\\n\\n\\nexports.isRegExp = function (obj) {\\n\\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\\n};\\n\\n\\nexports.isBuffer = function (obj) {\\n\\n    if (obj === null ||\\n        typeof obj === 'undefined') {\\n\\n        return false;\\n    }\\n\\n    return !!(obj.constructor &&\\n              obj.constructor.isBuffer &&\\n              obj.constructor.isBuffer(obj));\\n};\\n\"\n  ]\n}"}